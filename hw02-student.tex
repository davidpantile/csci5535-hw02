\documentclass[11pt]{exam}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathptmx}

\usepackage{xspace}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{mathpartir} %% for inference rules

%% Listings
\usepackage{listings}
\lstdefinestyle{default}{%
  basicstyle=\ttfamily,%
  commentstyle=\sl,%
  keywordstyle=\bf,%
  columns=fullflexible,%
  keepspaces=true,%
  mathescape%
}
\lstset{style=default}
\newcommand{\ocaml}[1]{\lstset{language=[Objective]Caml}\lstinline~#1~}
\lstnewenvironment{OCaml}
  {\lstset{language=[Objective]Caml}}
  {}

\title{CSCI 5535: Homework Assignment 2: Language Design and Implementation}
\author{
    David Baines
    \thanks{https://courses.cs.cornell.edu/cs412/2004sp/lectures/lec13.pdf}
    \thanks{https://csci3155.cs.colorado.edu/csci3155-notes.pdf}
    \thanks{https://www.hedonisticlearning.com/posts/understanding-typing-judgments.html}
}

%% Number questions by section
\renewcommand{\thequestion}{\thesection.\arabic{question}}

%% toggle math mode and text mode for tabular and array
\newcolumntype{C}{>{$}c<{$}}
\newcolumntype{L}{>{$}l<{$}}
\newcolumntype{R}{>{$}r<{$}}

\newcommand{\fmtkw}[1]{\mathtt{#1}}

\newcommand{\Typ}{\ensuremath{\mathsf{Typ}}}
\newcommand{\typ}{\ensuremath{\mathit{\tau}}}
\newcommand{\numtyp}{\ensuremath{\fmtkw{num}}}
\newcommand{\booltyp}{\ensuremath{\fmtkw{bool}}}

\newcommand{\Expr}{\ensuremath{\mathsf{Exp}}}
\newcommand{\expr}{\ensuremath{\mathit{e}}}

\newcommand{\addra}[1]{\ensuremath{\fmtkw{addr}[#1]}}
\newcommand{\addr}{\ensuremath{\mathit{a}}}
\newcommand{\numa}[1]{\ensuremath{\fmtkw{num}[#1]}}
\newcommand{\num}{\ensuremath{\mathit{n}}}
\newcommand{\boola}[1]{\ensuremath{\fmtkw{bool}[#1]}}
\newcommand{\bool}{\ensuremath{\mathit{b}}}
\newcommand{\plusa}[2]{\ensuremath{\fmtkw{plus}(#1; #2)}}
\newcommand{\plusc}[2]{\ensuremath{#1 \mathbin{\fmtkw{+}} #2}}
\newcommand{\timesa}[2]{\ensuremath{\fmtkw{times}(#1; #2)}}
\newcommand{\timesc}[2]{\ensuremath{#1 \mathbin{\fmtkw{*}} #2}}
\newcommand{\eqa}[2]{\ensuremath{\fmtkw{eq}(#1; #2)}}
\newcommand{\eqc}[2]{\ensuremath{#1 \mathrel{\fmtkw{==}} #2}}
\newcommand{\lea}[2]{\ensuremath{\fmtkw{le}(#1; #2)}}
\newcommand{\lec}[2]{\ensuremath{#1 \mathrel{\fmtkw{<=}} #2}}
\newcommand{\nota}[1]{\ensuremath{\fmtkw{not}(#1)}}
\newcommand{\notc}[1]{\ensuremath{\mathord{\fmtkw{!}}#1}}
\newcommand{\anda}[2]{\ensuremath{\fmtkw{and}(#1; #2)}}
\newcommand{\andc}[2]{\ensuremath{#1 \mathbin{\fmtkw{\&\&}} #2}}
\newcommand{\ora}[2]{\ensuremath{\fmtkw{or}(#1; #2)}}
\newcommand{\orc}[2]{\ensuremath{#1 \mathbin{\fmtkw{||}} #2}}

\newcommand{\Cmd}{\ensuremath{\mathsf{Cmd}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\skipa}{\ensuremath{\fmtkw{skip}}}
\newcommand{\seta}[2]{\ensuremath{\fmtkw{set}[#1](#2)}}
\newcommand{\setc}[2]{\ensuremath{#1 \mathrel{\fmtkw{:=}} #2}}
\newcommand{\seqa}[2]{\ensuremath{\fmtkw{seq}(#1; #2)}}
\newcommand{\seqc}[2]{\ensuremath{#1\fmtkw{;}\;#2}}
\newcommand{\ifa}[3]{\ensuremath{\fmtkw{if}(#1; #2; #3)}}
\newcommand{\ifc}[3]{\ensuremath{\fmtkw{if}\;#1\;\fmtkw{then}\;#2\;\fmtkw{else}\;#3}}
\newcommand{\whilea}[2]{\ensuremath{\fmtkw{while}(#1; #2)}}
\newcommand{\whilec}[2]{\ensuremath{\fmtkw{while}\;#1\;\fmtkw{do}\;#2}}

\newcommand{\Addr}{\ensuremath{\mathsf{Addr}}}

\newcommand{\store}{\ensuremath{\sigma}}
\newcommand{\storelet}[2]{\ensuremath{#1 \hookrightarrow #2}}
\newcommand{\xstore}[3]{#1, \storelet{#2}{#3}}

\newcommand{\IMP}{\textbf{\textsf{IMP}}\xspace}

\newcommand{\E}{\textbf{\textsf{E}}\xspace}
\newcommand{\T}{\textbf{\textsf{T}}\xspace}
\renewcommand{\P}{\textbf{\textsf{P}}\xspace}
\renewcommand{\S}{\textbf{\textsf{S}}\xspace}
\newcommand{\ET}{\textbf{\textsf{ET}}\xspace}
\newcommand{\ETP}{\textbf{\textsf{ETP}}\xspace}
\newcommand{\ETPS}{\textbf{\textsf{ETPS}}\xspace}

\newcommand{\state}[2]{\langle #1, #2 \rangle}

\newcommand{\hasType}[2]{\ensuremath{#1 : #2}}
\newcommand{\hypJ}[2]{\ensuremath{#1 \vdash #2}}
\newcommand{\isOk}[1]{\ensuremath{#1\;\mathsf{ok}}}
\newcommand{\eval}[2]{\ensuremath{#1 \Downarrow #2}}
\newcommand{\step}[2]{\ensuremath{#1 \longmapsto #2}}
\newcommand{\stepspap}[3][\typ]{\ensuremath{#2 \hookrightarrow_{:#1} #3}}
\newcommand{\isVal}[1]{\ensuremath{#1\;\mathsf{val}}}
\newcommand{\isFinal}[1]{\ensuremath{#1\;\mathsf{final}}}

\newcommand{\even}{\operatorname{even}}

%%%%%%%%%%%%%%
% Baines custom commands
%%%%%%%%%%%%%%

\newcommand{\mycomment}[1]{}

\pagestyle{plain}
\begin{document}
\maketitle

\section{Language Design: \IMP}

\begin{questions}
  \question The two judgment forms (one for expressions, the other for functions / commands, respectively \expr \; and \cmd \; in \IMP, are:

\mycomment{

    \begin{mathpar}
    \inferrule{
        \Gamma , \hasType{x_1}{\tau_1} \vdash \hasType{e_2}{\tau_2} \\
        \Gamma , \hasType{\cmd(\tau_1)}{\tau_2} \vdash \hasType{e}{\tau}
    }{
        \Gamma \vdash \texttt{fun}[\tau_1;\tau_2] \hasType{(x_1.e_2; f.e)}{\tau}
    }

    \inferrule{
        \Gamma \vdash \hasType{c(\tau_1)}{\tau_2} \\
        \Gamma \vdash \hasType{e}{\tau_1}
    }{
        \Gamma \vdash \texttt{call}[c] \hasType{(e)}{\tau_2}
    }
    \end{mathpar}

}

For $e$:

\begin{mathpar}
    \inferrule{
    }{
        \Gamma \vdash \hasType{\addra{a}}{\numtyp}
    }
    
    \inferrule{
    }{
        \Gamma \vdash \hasType{\numa{n}}{\numtyp}
    }
    
    \inferrule{
    }{
        \Gamma \vdash \hasType{\boola{b}}{\booltyp}
    }

    \inferrule{
        \Gamma \vdash \hasType{e_1}{\numtyp} \\ 
        \Gamma \vdash \hasType{e_2}{\numtyp}
    }{
        \Gamma \vdash \hasType{\plusa{e_1}{e_2}}{\numtyp}
    }

    \inferrule{
        \Gamma \vdash \hasType{e_1}{\numtyp} \\ 
        \Gamma \vdash \hasType{e_2}{\numtyp}
    }{
        \Gamma \vdash \hasType{\timesa{e_1}{e_2}}{\numtyp}
    }

    \inferrule{
        \Gamma \vdash \hasType{e_1}{\numtyp} \\ 
        \Gamma \vdash \hasType{e_2}{\numtyp}
    }{
        \Gamma \vdash \hasType{\eqa{e_1}{e_2}}{\booltyp}
    }

    \inferrule{
        \Gamma \vdash \hasType{e_1}{\booltyp} \\ 
        \Gamma \vdash \hasType{e_2}{\booltyp}
    }{
        \Gamma \vdash \hasType{\eqa{e_1}{e_2}}{\booltyp}
    }

    \inferrule{
        \Gamma \vdash \hasType{e_1}{\numtyp} \\ 
        \Gamma \vdash \hasType{e_2}{\numtyp}
    }{
        \Gamma \vdash \hasType{\lea{e_1}{e_2}}{\booltyp}
    }

    \inferrule{
        \Gamma \vdash \hasType{e}{\numtyp}
    }{
        \Gamma \vdash \hasType{\nota{e}}{\booltyp}
    }

    \inferrule{
        \Gamma \vdash \hasType{e}{\booltyp}
    }{
        \Gamma \vdash \hasType{\nota{e}}{\booltyp}
    }

    \inferrule{
        \Gamma \vdash \hasType{e_1}{\booltyp} \\
        \Gamma \vdash \hasType{e_2}{\booltyp}
    }{
        \Gamma \vdash \hasType{\anda{e_1}{e_2}}{\booltyp}
    }

    \inferrule{
        \Gamma \vdash \hasType{e_1}{\booltyp} \\
        \Gamma \vdash \hasType{e_2}{\booltyp}
    }{
        \Gamma \vdash \hasType{\ora{e_1}{e_2}}{\booltyp}
    }
  
\end{mathpar}

    For $c$:

\begin{mathpar}
    \inferrule{
        \Gamma \vdash \hasType{e}{\booltyp}
    }{
        \Gamma \vdash \hasType{\nota{e}}{\booltyp}
    }
\end{mathpar}

    \question
    \begin{itemize}
        \item[(a)] 
        
        For the evals:
        
        \begin{mathpar}
        

            \inferrule{ }{\addra{a} \isVal{}}

            \inferrule{ }{\numa{n} \isVal{}}
            
            \inferrule{ }{\boola{b} \isVal{}}
            
            \\\\
            
        \end{mathpar}
            
For ``plus()'':    

		\begin{mathpar} 

            \inferrule{
            	n_1 + n_2 = n
            }{ 
            	\step{
            		\plusa{\numa{n_1}}{\numa{n_2}}
            	}{
            		\numa{n}
            	}
            }
            
            \inferrule{
            	\step{
            		e_1
            	}{
            		e_1^\prime
            	}
            }
            {
            	\step{
            		\plusa{e_1}{e_2}
            	}{
            		\plusa{e_1^\prime}{e_2}
            	}
            }

            \inferrule{
            	\expr \isVal{} \\
            	\step{
            		e_2
            	}{
            		e_2^\prime
            	}
            }
            {
            	\step{
            		\plusa{e_1}{e_2}
            	}{
            		\plusa{e_1}{e_2^\prime}
            	}
            }
            
      \end{mathpar}
            
For ``times()'':     

		\begin{mathpar}
           
            \inferrule{
            	n_1 * n_2 = n
            }{ 
            	\step{
            		\timesa{
            			\numa{n_1}
            		}{
            			\numa{n_2}
            		}
            	}{
            		\numa{n}
            	}
            }
            
            \inferrule{
            	\step{
            		e_1
            	}{
            		e_1^\prime
            	}
            }
            {
            	\step{
            		\timesa{
            			e_1
            		}{
            			e_2
            		}
            	}{
            		\timesa{e_1^\prime}{e_2}
            	}
            }

            \inferrule{
            	\expr \isVal{} \\
            	\step{
            		e_2
            	}{
            		e_2^\prime
            	}
            }
            {
            	\step{
            		\timesa{e_1}{e_2}
            	}{
            		\timesa{e_1}{e_2^\prime}
            	}
            }
            
      \end{mathpar}
            
For ``eq()'':   

		\begin{mathpar}  
        
            \inferrule{
            	n_1 == n_2 \vdash b
            }{ 
            	\step{
            		\eqa{\numa{n_1}}{\numa{n_2}}
            	}{
            		\boola{b}
            	}
            }
            
            \inferrule{
            	\step{
            		e_1
            	}{
            		e_1^\prime
            	}
            }
            {
            	\step{
            		\eqa{e_1}{e_2}
            	}{
            		\eqa{e_1^\prime}{e_2}
            	}
            }

            \inferrule{
            	\expr \isVal{} \\
            	\step{
            		e_2
            	}{
            		e_2^\prime
            	}
            }
            {
            	\step{
            		\eqa{e_1}{e_2}
            	}{
            		\eqa{e_1}{e_2^\prime}
            	}
            }
            
     \end{mathpar}
            
For ``le()'':  

		\begin{mathpar}   
      
            \inferrule{
            	n_1 <= n_2 \vdash b
            }{ 
            	\step{
            		\lea{\numa{n_1}}{\numa{n_2}}
            	}{
            		\boola{b}
            	}
            }
            
            \inferrule{
            	\step{
            		e_1
            	}{
            		e_1^\prime
            	}
            }
            {
            	\step{
            		\lea{e_1}{e_2}
            	}{
            		\lea{e_1^\prime}{e_2}
            	}
            }

            \inferrule{
            	\expr \isVal{} \\
            	\step{
            		e_2
            	}{
            		e_2^\prime
            	}
            }
            {
            	\step{
            		\lea{e_1}{e_2}
            	}{
            		\lea{e_1}{e_2^\prime}
            	}
            }
            
      \end{mathpar}
            
For ``not()'':    


		\begin{mathpar} 
   
            \inferrule{
            	n_1 ! \; n_2 \; || \;  b_1 ! \; b_2 \vdash b
            }{ 
            	\step{
            		\nota{\numa{n_1}}{\numa{n_2}} \; || \;
            		\nota{\boola{b_1}}{\boola{b_2}}
            	}{
            		\boola{b}
            	}
            }
            
            \inferrule{
            	\step{
            		e_1
            	}{
            		e_1^\prime
            	}
            }
            {
            	\step{
            		\nota{e_1}{e_2}
            	}{
            		\nota{e_1^\prime}{e_2}
            	}
            }

            \inferrule{
            	\expr \isVal{} \\
            	\step{
            		e_2
            	}{
            		e_2^\prime
            	}
            }
            {
            	\step{
            		\nota{e_1}{e_2}
            	}{
            		\nota{e_1}{e_2^\prime}
            	}
            }
            
       \end{mathpar}
            
For ``and()'':

		\begin{mathpar}
         
            \inferrule{
            	b_1 \; \&\& \; b_2 \vdash b
            }{ 
            	\step{
            		\anda{\boola{b_1}}{\boola{b_2}}
            	}{
            		\boola{b}
            	}
            }
            
            \inferrule{
            	\step{
            		e_1
            	}{
            		e_1^\prime
            	}
            }
            {
            	\step{
            		\nota{e_1}{e_2}
            	}{
            		\nota{e_1^\prime}{e_2}
            	}
            }

            \inferrule{
            	\expr \isVal{} \\
            	\step{
            		e_2
            	}{
            		e_2^\prime
            	}
            }
            {
            	\step{
            		\nota{e_1}{e_2}
            	}{
            		\nota{e_1}{e_2^\prime}
            	}
            }
        \end{mathpar}
    \end{itemize}
\end{questions}

\section{Language Implementation: \ETPS}

See \texttt{hw02.ml} and \texttt{test\_hw02.ml}.

\section{Final Project Preparation: Pre-Proposal}

\begin{questions}
  \question
\end{questions}

%% Appendix
\clearpage
\appendix

\section{Syntax of \IMP}

\[\begin{array}{lrcllL}
\Typ & \typ & ::= & \numtyp & \numtyp & numbers
\\
&&& \booltyp & \booltyp & booleans
\\
\Expr & \expr & ::= & \addra{\addr} & \addr & addresses (or ``assignables'') 
\\ 
&&& \numa{\num} & \num & numeral
\\
&&& \boola{\bool} & \bool & boolean
\\
&&& \plusa{\expr_1}{\expr_2} & \plusc{\expr_1}{\expr_2} & addition
\\
&&& \timesa{\expr_1}{\expr_2} & \timesc{\expr_1}{\expr_2} & multiplication
\\
&&& \eqa{\expr_1}{\expr_2} & \eqc{\expr_1}{\expr_2} & equal
\\
&&& \lea{\expr_1}{\expr_2} & \lec{\expr_1}{\expr_2} & less-than-or-equal
\\
&&& \nota{\expr_1} & \notc{\expr_1} & negation
\\
&&& \anda{\expr_1}{\expr_2} & \andc{\expr_1}{\expr_2} & conjunction
\\
&&& \ora{\expr_1}{\expr_2} & \orc{\expr_1}{\expr_2} & disjunction
\\
\Cmd & \cmd & ::= & \seta{\addr}{\expr} & \setc{\addr}{\expr} & assignment
\\
&&& \skipa & \skipa & skip
\\
&&& \seqa{\cmd_1}{\cmd_2} & \seqc{\cmd_1}{\cmd_2} & sequencing
\\
&&& \ifa{\expr}{\cmd_1}{\cmd_2} & \ifc{\expr}{\cmd_1}{\cmd_2} & conditional
\\
&&& \whilea{\expr}{\cmd_1} & \whilec{\expr}{\cmd_1} & looping
\\
\Addr & \addr
\end{array}\]

\end{document}\\